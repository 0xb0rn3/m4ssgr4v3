#!/bin/bash

# ==============================================================================
# S3RP UNIFIED RED TEAM FRAMEWORK
# Author: oxbv1 | 0xb0rn3
# AI Collaboration: Developed in cooperation with Google Gemini
# Version: 2.0 - Complete Modular Integration
# ==============================================================================
# This framework represents the evolution of scan01 through scan09, combined
# into a single, cohesive toolkit. Every function here can be copied and
# modified to build your own custom security framework. The code is structured
# to teach you not just WHAT it does, but WHY it does it.
# ==============================================================================

# ============================================
# SECTION 1: COLOR DEFINITIONS & UI ELEMENTS
# ============================================
# Why colors matter: When you're juggling multiple terminals during a real
# engagement, visual differentiation isn't just aestheticâ€”it's operational.
# You need to know at a glance which terminal is running your stealth scan
# versus your aggressive enumeration.
#
# Modify this section to: Create your own color scheme, add more granular
# color coding (like different colors for errors vs warnings vs info), or
# even implement terminal theme detection to auto-adjust colors.

RED='\033[1;31m'      # Critical alerts, errors, aggressive mode indicators
GRN='\033[1;32m'      # Success messages, completed operations
YEL='\033[1;33m'      # Warnings, user prompts, important notices
BLU='\033[0;34m'      # Informational messages
CYN='\033[0;36m'      # Process indicators, status updates
WHT='\033[1;37m'      # Headers, important data highlights
DGRY='\033[1;30m'     # Subdued information, metadata
NC='\033[0m'          # No Color - ALWAYS reset after colored output

# ============================================
# SECTION 2: GLOBAL CONFIGURATION VARIABLES
# ============================================
# Centralizing configuration makes your framework maintainable. When you need
# to change a default value, you do it once here rather than hunting through
# hundreds of lines of code. This is professional development practice.
#
# Modify this section to: Add your preferred tool paths, default wordlist
# locations, API keys for vulnerability databases, notification webhooks,
# or any other framework-wide settings you use regularly.

FRAMEWORK_VERSION="2.0"
FRAMEWORK_NAME="s3rp"
OPERATION_PREFIX="s3rp_OP"

# Default scanning parameters (learned from scan01-scan09 evolution)
DEFAULT_TIMING="-T4"                    # Balanced speed/stealth from scan02
DEFAULT_MIN_RATE="500"                  # Concurrency boost from scan01
DEFAULT_MTU="16"                        # Fragmentation size from scan04
DEFAULT_DECOYS="10"                     # Number of decoy IPs from scan04

# Tool commands (allows easy swapping of tool versions)
PROXY_CMD="proxychains4 -q"            # Anonymity layer from scan06
NMAP_CMD="nmap"
GOBUSTER_CMD="gobuster"
SEARCHSPLOIT_CMD="searchsploit"
XSLTPROC_CMD="xsltproc"

# Directory structure (organized like scan07-scan09)
MSF_RESOURCE_DIR="metasploit_resources"
WEB_DISCOVERY_DIR="web_discovery"
RECON_DIR="recon"
EXPLOIT_DIR="exploitation"
LOG_DIR="logs"
REPORT_DIR="reports"

# Feature flags (enable/disable functionality)
ENABLE_PROXY=false
ENABLE_WEB_ENUM=true
ENABLE_EXPLOIT_SEARCH=true
ENABLE_MSF_INTEGRATION=true
ENABLE_VERBOSE_LOGGING=false

# ============================================
# SECTION 3: SIGNAL HANDLING & CLEANUP
# ============================================
# Professional tools handle interruptions gracefully. You don't want to leave
# half-written files or orphaned processes when someone hits Ctrl+C.
#
# Modify this section to: Add cleanup for specific temporary files you create,
# kill background processes, or save state so you can resume operations.

trap cleanup_on_exit INT TERM

cleanup_on_exit() {
    echo -e "\n${YEL}[!] Interrupt received. Cleaning up...${NC}"
    
    # Kill any background jobs this script started
    jobs -p | xargs -r kill 2>/dev/null
    
    # Save current state if session exists
    if [ -n "$SESSION_DIR" ] && [ -d "$SESSION_DIR" ]; then
        echo "$(date): Session interrupted by user" >> "$SESSION_DIR/$LOG_DIR/session.log"
        echo -e "${CYN}[*] Session data preserved in: $SESSION_DIR${NC}"
    fi
    
    echo -e "${RED}[!] Framework terminated.${NC}"
    exit 130
}

# ============================================
# SECTION 4: FRAMEWORK BANNER
# ============================================
# The banner serves multiple purposes: branding, version tracking, and visual
# confirmation that the correct tool launched. This is your framework's identity.
#
# Modify this section to: Create your own ASCII art, add dynamic information
# like current IP or active proxy status, or pull system information that's
# relevant to your operations.

show_banner() {
    clear
    echo -e "${RED}"
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— "
    echo "  â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—"
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•"
    echo "  â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â•šâ•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â• "
    echo "  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     "
    echo "  â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     "
    echo -e "${WHT}      [ UNIFIED RED TEAM FRAMEWORK v${FRAMEWORK_VERSION} ]${NC}"
    echo -e "${CYN}      [ DEVELOPER: oxbv1 | 0xb0rn3 ]${NC}"
    echo -e "${CYN}      [ AI-ASSISTED: Google Gemini ]${NC}"
    echo -e "${DGRY}      [ Evolution of scan01-scan09 ]${NC}"
    echo "=========================================================="
    echo ""
}

# ============================================
# SECTION 5: PRIVILEGE VERIFICATION
# ============================================
# Many security tools need raw socket access, which requires root. Checking
# early prevents confusing failures halfway through a scan. This is learned
# from scan03's evolution where privilege issues caused problems.
#
# Modify this section to: Add checks for specific capabilities instead of
# just root, detect if running in containers/VMs, or check for sudo access.

check_privileges() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}[!] CRITICAL: Root privileges required${NC}"
        echo -e "${YEL}[*] Many scanning techniques require raw socket access${NC}"
        echo -e "${YEL}[*] Please run with: sudo $0${NC}"
        exit 1
    fi
    echo -e "${GRN}[âœ“] Privilege check passed${NC}"
}

# ============================================
# SECTION 6: DEPENDENCY MANAGEMENT SYSTEM
# ============================================
# This is one of the most important evolutions from scan01 to scan09. Early
# versions just assumed tools were installed. Professional frameworks check
# dependencies and offer to install them. This prevents mid-scan failures.
#
# Modify this section to: Add more tools based on your workflow, check for
# minimum versions, validate tool configurations, or add platform-specific
# installation methods.

check_dependencies() {
    echo -e "${CYN}[*] Checking framework dependencies...${NC}"
    
    # Core tools (required for basic functionality)
    local required_tools=("nmap" "grep" "awk" "sed")
    
    # Enhanced tools (needed for full functionality like scan07-scan09)
    local enhanced_tools=("searchsploit" "gobuster" "xsltproc")
    
    # Optional tools (nice to have but not critical)
    local optional_tools=("msfconsole" "proxychains4" "masscan" "nikto")
    
    local missing_required=()
    local missing_enhanced=()
    local missing_optional=()
    
    # Check each category
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_required+=("$tool")
        fi
    done
    
    for tool in "${enhanced_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_enhanced+=("$tool")
        fi
    done
    
    for tool in "${optional_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_optional+=("$tool")
        fi
    done
    
    # Handle missing required tools (critical - must install)
    if [ ${#missing_required[@]} -ne 0 ]; then
        echo -e "${RED}[!] Missing REQUIRED tools: ${missing_required[*]}${NC}"
        echo -e "${YEL}[?] Attempt automatic installation? (y/n)${NC}"
        read -r response
        
        if [[ "$response" == "y" ]]; then
            install_dependencies "${missing_required[@]}"
        else
            echo -e "${RED}[!] Cannot proceed without required tools${NC}"
            exit 1
        fi
    fi
    
    # Handle missing enhanced tools (impacts functionality)
    if [ ${#missing_enhanced[@]} -ne 0 ]; then
        echo -e "${YEL}[!] Missing ENHANCED tools: ${missing_enhanced[*]}${NC}"
        echo -e "${YEL}[*] Some features will be disabled without these${NC}"
        echo -e "${YEL}[?] Attempt installation? (y/n)${NC}"
        read -r response
        
        if [[ "$response" == "y" ]]; then
            install_dependencies "${missing_enhanced[@]}"
        fi
    fi
    
    # Just inform about optional tools
    if [ ${#missing_optional[@]} -ne 0 ]; then
        echo -e "${CYN}[*] Optional tools not found: ${missing_optional[*]}${NC}"
        echo -e "${CYN}[*] Advanced features will be limited${NC}"
    fi
    
    echo -e "${GRN}[âœ“] Dependency check complete${NC}"
}

# This function handles the actual installation logic
install_dependencies() {
    local tools=("$@")
    
    echo -e "${CYN}[*] Attempting to install: ${tools[*]}${NC}"
    
    # Detect package manager and OS
    if [ -f /etc/debian_version ]; then
        echo -e "${CYN}[*] Detected Debian/Ubuntu-based system${NC}"
        apt-get update -qq
        for tool in "${tools[@]}"; do
            apt-get install -y "$tool" || echo -e "${YEL}[!] Failed to install $tool${NC}"
        done
    elif [ -f /etc/redhat-release ]; then
        echo -e "${CYN}[*] Detected RedHat/Fedora-based system${NC}"
        for tool in "${tools[@]}"; do
            dnf install -y "$tool" || echo -e "${YEL}[!] Failed to install $tool${NC}"
        done
    elif [ -f /etc/arch-release ]; then
        echo -e "${CYN}[*] Detected Arch-based system${NC}"
        for tool in "${tools[@]}"; do
            pacman -S --noconfirm "$tool" || echo -e "${YEL}[!] Failed to install $tool${NC}"
        done
    else
        echo -e "${RED}[!] Unknown system. Please install manually: ${tools[*]}${NC}"
        return 1
    fi
    
    echo -e "${GRN}[âœ“] Installation attempt complete${NC}"
}

# ============================================
# SECTION 7: PROXY & ANONYMITY LAYER
# ============================================
# Learned from scan06-scan09: ProxyChains integration for anonymity. Real
# red team operations require OpSec. This checks if proxychains is available
# and properly configured before routing traffic through it.
#
# Modify this section to: Add VPN checks, Tor circuit verification, check
# proxy chain health, or implement automatic proxy configuration.

check_proxy_layer() {
    echo -ne "${CYN}[*] Checking anonymity layer... ${NC}"
    
    if command -v proxychains4 &> /dev/null; then
        if [ -f /etc/proxychains4.conf ]; then
            # Verify proxychains config has actual proxies
            if grep -q "^[^#]*socks\|^[^#]*http" /etc/proxychains4.conf; then
                echo -e "${GRN}[ACTIVE]${NC}"
                ENABLE_PROXY=true
                return 0
            else
                echo -e "${YEL}[UNCONFIGURED]${NC}"
                echo -e "${YEL}[!] ProxyChains found but no proxies configured${NC}"
                ENABLE_PROXY=false
                return 1
            fi
        else
            echo -e "${YEL}[MISSING CONFIG]${NC}"
            ENABLE_PROXY=false
            return 1
        fi
    else
        echo -e "${RED}[NOT INSTALLED]${NC}"
        echo -e "${YEL}[!] ProxyChains not available - operating without anonymity layer${NC}"
        echo -e "${YEL}[!] Your actual IP will be exposed to targets${NC}"
        ENABLE_PROXY=false
        return 1
    fi
}

# ============================================
# SECTION 8: SESSION INITIALIZATION
# ============================================
# Proper session management is critical. This creates an organized directory
# structure for all your operation data. Learned from scan07-scan09 where
# data organization became increasingly important as complexity grew.
#
# Modify this section to: Add automatic note-taking templates, evidence
# chain tracking, client-specific directory structures, or integration with
# case management systems like Dradis or Faraday.

initialize_session() {
    local session_name="${OPERATION_PREFIX}_$(date +%Y%m%d_%H%M%S)"
    SESSION_DIR="$session_name"
    
    echo -e "${CYN}[*] Initializing session: $session_name${NC}"
    
    # Create complete directory structure (learned from scan07-scan09)
    mkdir -p "$SESSION_DIR"/{$RECON_DIR,$WEB_DISCOVERY_DIR,$EXPLOIT_DIR,$LOG_DIR,$REPORT_DIR}
    mkdir -p "$SESSION_DIR/$MSF_RESOURCE_DIR"
    
    # Create session metadata file (important for tracking multiple operations)
    cat > "$SESSION_DIR/session_info.txt" <<EOF
Session ID: $session_name
Framework Version: $FRAMEWORK_VERSION
Start Time: $(date '+%Y-%m-%d %H:%M:%S')
Operator: $(whoami)
Hostname: $(hostname)
System: $(uname -a)
Working Directory: $(pwd)/$SESSION_DIR
Proxy Enabled: $ENABLE_PROXY
EOF
    
    # Initialize session log
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Session initialized" >> "$SESSION_DIR/$LOG_DIR/session.log"
    
    echo -e "${GRN}[âœ“] Session initialized: $SESSION_DIR${NC}"
    export SESSION_DIR
}

# ============================================
# SECTION 9: TARGET CONFIGURATION
# ============================================
# Flexible target input supports different engagement types. This evolved
# from scan01's simple input to scan09's more sophisticated handling.
#
# Modify this section to: Add target validation (ping checks, DNS resolution),
# import from asset management databases, CIDR expansion verification, or
# integration with scope management tools.

configure_target() {
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘     TARGET ACQUISITION            â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo "1. Single Host (IP or hostname)"
    echo "2. Network Range (CIDR notation)"
    echo "3. Import from file"
    echo "4. Multiple targets (space-separated)"
    echo ""
    read -p "Selection [1-4]: " target_option
    
    case $target_option in
        1)
            read -p "Enter target IP or hostname: " TARGET
            echo "$TARGET" > "$SESSION_DIR/targets.txt"
            ;;
        2)
            read -p "Enter network range (e.g., 192.168.1.0/24): " TARGET
            echo "$TARGET" > "$SESSION_DIR/targets.txt"
            ;;
        3)
            read -p "Enter path to target file: " target_file
            if [ -f "$target_file" ]; then
                cp "$target_file" "$SESSION_DIR/targets.txt"
                TARGET="-iL $SESSION_DIR/targets.txt"
            else
                echo -e "${RED}[!] File not found${NC}"
                configure_target
                return
            fi
            ;;
        4)
            read -p "Enter targets (space-separated): " targets
            echo "$targets" | tr ' ' '\n' > "$SESSION_DIR/targets.txt"
            TARGET="-iL $SESSION_DIR/targets.txt"
            ;;
        *)
            echo -e "${RED}[!] Invalid option${NC}"
            configure_target
            return
            ;;
    esac
    
    # Log target selection
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Target configured: $TARGET" >> "$SESSION_DIR/$LOG_DIR/session.log"
    
    echo -e "${GRN}[âœ“] Target configured: $TARGET${NC}"
}

# ============================================
# SECTION 10: SCAN PROFILE SELECTION
# ============================================
# This is the heart of what makes this framework flexible. Different
# engagements need different approaches. These profiles evolved through
# scan01-scan09, each adding new tactics and evasion techniques.
#
# Modify this section to: Add your own custom profiles based on client types,
# create industry-specific presets (healthcare, finance, etc.), or implement
# adaptive profiles that change based on initial results.

select_scan_profile() {
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘     ENGAGEMENT PROFILE            â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "1. ${CYN}Ghost Mode${NC} - Maximum stealth (scan04 evasion techniques)"
    echo -e "   â””â”€ Fragmentation, decoys, MTU manipulation, slow timing"
    echo ""
    echo -e "2. ${BLU}Balanced Recon${NC} - Standard reconnaissance (scan01 baseline)"
    echo -e "   â””â”€ Service detection, OS fingerprinting, safe scripts"
    echo ""
    echo -e "3. ${YEL}Quick Survey${NC} - Fast initial assessment"
    echo -e "   â””â”€ Top 1000 ports, banner grabbing, minimal scripts"
    echo ""
    echo -e "4. ${RED}Vulnerability Hunt${NC} - Deep inspection (scan04 aggressive mode)"
    echo -e "   â””â”€ Vuln scripts, auth testing, brute-force attempts"
    echo ""
    echo -e "5. ${WHT}Total Infrastructure${NC} - Comprehensive audit (scan05 full scan)"
    echo -e "   â””â”€ All ports, OS detection, all safe scripts, slow but thorough"
    echo ""
    echo -e "6. ${GRN}Custom Configuration${NC} - Build your own (scan06+ flexibility)"
    echo -e "   â””â”€ Manual flag specification for advanced users"
    echo ""
    read -p "Selection [1-6]: " profile
    
    case $profile in
        1)  # Ghost Mode - Learned from scan04's evasion focus
            # -f: Fragment packets to evade IDS signature detection
            # --mtu 8: Extremely small MTU for maximum fragmentation
            # -g 53: Source port 53 (DNS) to bypass firewall rules
            # -D RND:10: Create 10 random decoy IPs to hide among
            # --data-length 32: Add random padding to packets
            # -T2: Slow timing to avoid triggering rate-based detection
            SCAN_FLAGS="-sS -Pn -f --mtu 8 -g 53 -D RND:$DEFAULT_DECOYS --data-length 32"
            TIMING="-T2"
            NSE_SCRIPTS="--script=banner,firewalk"
            PROFILE_NAME="Ghost_Mode"
            echo -e "${CYN}[*] Stealth configuration loaded${NC}"
            echo -e "${YEL}[!] This will be SLOW but very quiet${NC}"
            ;;
        2)  # Balanced Recon - scan01's reliable approach
            SCAN_FLAGS="-sS -sV -O --version-intensity 5"
            TIMING="-T4"
            NSE_SCRIPTS="--script=default,safe,discovery"
            PROFILE_NAME="Balanced_Recon"
            echo -e "${BLU}[*] Standard reconnaissance profile loaded${NC}"
            ;;
        3)  # Quick Survey - Fast initial assessment
            SCAN_FLAGS="-sS -sV --top-ports 1000"
            TIMING="-T5"
            NSE_SCRIPTS="--script=banner"
            PROFILE_NAME="Quick_Survey"
            echo -e "${YEL}[*] Quick survey mode - fast but less thorough${NC}"
            ;;
        4)  # Vulnerability Hunt - scan04's aggressive mode
            # --version-all: Maximum version detection intensity
            # --osscan-guess: Aggressive OS guessing
            SCAN_FLAGS="-sV --version-all -O --osscan-guess"
            TIMING="-T4"
            NSE_SCRIPTS="--script=vuln,exploit,auth,brute"
            PROFILE_NAME="Vuln_Hunt"
            echo -e "${RED}[*] Vulnerability hunting mode${NC}"
            echo -e "${YEL}[!] WARNING: This uses intrusive scripts${NC}"
            ;;
        5)  # Total Infrastructure - scan05's comprehensive approach
            # -p-: Scan ALL 65535 ports
            # -A: Enable OS detection, version detection, script scanning, traceroute
            SCAN_FLAGS="-p- -A -sV --version-intensity 9"
            TIMING="-T4"
            NSE_SCRIPTS="--script=default,safe,discovery,vuln"
            PROFILE_NAME="Total_Infrastructure"
            echo -e "${WHT}[*] Total infrastructure audit${NC}"
            echo -e "${YEL}[!] This will take considerable time${NC}"
            ;;
        6)  # Custom - scan06+ flexibility for advanced users
            echo -e "${GRN}[*] Custom configuration mode${NC}"
            read -p "Enter nmap flags (e.g., -sS -sV -p 1-1000): " SCAN_FLAGS
            read -p "Enter timing template [0-5, default 4]: " custom_timing
            TIMING="-T${custom_timing:-4}"
            read -p "Enter NSE scripts (comma-separated, or enter to skip): " custom_scripts
            NSE_SCRIPTS="${custom_scripts:+--script=$custom_scripts}"
            PROFILE_NAME="Custom"
            ;;
        *)
            echo -e "${RED}[!] Invalid selection, defaulting to Balanced Recon${NC}"
            SCAN_FLAGS="-sS -sV -O"
            TIMING="-T4"
            NSE_SCRIPTS="--script=default,safe"
            PROFILE_NAME="Balanced_Recon"
            ;;
    esac
    
    # Log profile selection
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Profile selected: $PROFILE_NAME" >> "$SESSION_DIR/$LOG_DIR/session.log"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Flags: $SCAN_FLAGS $TIMING $NSE_SCRIPTS" >> "$SESSION_DIR/$LOG_DIR/session.log"
    
    echo -e "${GRN}[âœ“] Profile configured: $PROFILE_NAME${NC}"
}

# ============================================
# SECTION 11: CORE SCANNING ENGINE
# ============================================
# This is where everything comes together. The scanning engine executes nmap
# with all the configured parameters. Learned from scan01-scan09's evolution
# in output handling, filtering, and multi-format logging.
#
# Modify this section to: Add real-time port notifications (when port 22, 80,
# 443 open), integrate with notification systems (Slack, Discord, email),
# implement automatic pause/resume on connection issues.

execute_scan() {
    local output_base="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}"
    
    echo -e "\n${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘     SCAN EXECUTION                â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${CYN}[*] Target: $TARGET${NC}"
    echo -e "${CYN}[*] Profile: $PROFILE_NAME${NC}"
    echo -e "${CYN}[*] Flags: $SCAN_FLAGS $TIMING${NC}"
    echo -e "${CYN}[*] Scripts: $NSE_SCRIPTS${NC}"
    echo -e "${CYN}[*] Proxy: $([ "$ENABLE_PROXY" = true ] && echo "Enabled" || echo "Disabled")${NC}"
    echo ""
    
    # Construct the complete nmap command
    # -n: No DNS resolution (faster, less noise)
    # -Pn: Treat all hosts as online (skip ping)
    # --open: Only show open ports
    # --stats-every 30s: Progress updates every 30 seconds
    # --min-rate: Minimum packet rate for speed
    local nmap_cmd="$NMAP_CMD -n -Pn --open --stats-every 30s --min-rate $DEFAULT_MIN_RATE"
    nmap_cmd="$nmap_cmd $TIMING $SCAN_FLAGS $NSE_SCRIPTS $TARGET"
    nmap_cmd="$nmap_cmd -oA $output_base"  # Output All formats
    
    # Add proxy layer if enabled (from scan06-scan09)
    if [ "$ENABLE_PROXY" = true ]; then
        echo -e "${GRN}[âœ“] Routing through proxy chain${NC}"
        nmap_cmd="$PROXY_CMD $nmap_cmd"
    fi
    
    # Log the exact command being executed
    echo "$nmap_cmd" > "$SESSION_DIR/$LOG_DIR/scan_command.log"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Scan started" >> "$SESSION_DIR/$LOG_DIR/session.log"
    
    echo -e "${YEL}[!] Executing scan... (this may take several minutes)${NC}"
    echo -e "${DGRY}[*] Press Ctrl+C to interrupt (cleanup will occur automatically)${NC}\n"
    
    # Execute and filter noise (learned from scan02's output cleaning)
    # We filter out nmap's standard banners and tcpwrapped noise
    eval "$nmap_cmd" 2>&1 | \
        grep -vE "Starting Nmap|Nmap done|tcpwrapped|Nmap scan report for" | \
        tee "$SESSION_DIR/$LOG_DIR/scan_output.log"
    
    echo ""
    echo -e "${GRN}[âœ“] Scan execution complete${NC}"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Scan completed" >> "$SESSION_DIR/$LOG_DIR/session.log"
    
    # Generate HTML report if xsltproc available (scan03+ feature)
    if command -v "$XSLTPROC_CMD" &> /dev/null && [ -f "${output_base}.xml" ]; then
        echo -e "${CYN}[*] Generating HTML report...${NC}"
        $XSLTPROC_CMD "${output_base}.xml" -o "${output_base}.html" 2>/dev/null
        if [ -f "${output_base}.html" ]; then
            echo -e "${GRN}[âœ“] HTML report generated${NC}"
        fi
    fi
    
    # Quick results parsing for immediate feedback
    parse_scan_results "$output_base"
}

# ============================================
# SECTION 12: SCAN RESULTS PARSER
# ============================================
# Raw nmap output is verbose and hard to process quickly. This parser extracts
# the critical information and presents it in an actionable format. Evolved
# from scan02's simple filtering to scan07's intelligent parsing.
#
# Modify this section to: Add severity ranking (critical vs info ports),
# automatic categorization by service type, integration with vulnerability
# databases for instant risk assessment, or custom alerting logic.

parse_scan_results() {
    local scan_base=$1
    local gnmap_file="${scan_base}.gnmap"
    
    if [ ! -f "$gnmap_file" ]; then
        echo -e "${RED}[!] Scan results file not found${NC}"
        return
    fi
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘     SCAN RESULTS SUMMARY          â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    # Count live hosts
    local live_hosts=$(grep -c "Status: Up" "$gnmap_file")
    echo -e "${GRN}Live Hosts Discovered: $live_hosts${NC}\n"
    
    # Extract and display open ports by host
    echo -e "${CYN}Open Ports by Host:${NC}"
    echo -e "${DGRY}$(printf '%.0sâ”€' {1..50})${NC}"
    
    grep "Ports:" "$gnmap_file" | while IFS= read -r line; do
        local host=$(echo "$line" | awk '{print $2}')
        local hostname=$(echo "$line" | awk '{print $3}' | tr -d '()')
        
        # Display host with hostname if available
        if [ -n "$hostname" ] && [ "$hostname" != "$host" ]; then
            echo -e "\n${GRN}$host${NC} ${DGRY}($hostname)${NC}"
        else
            echo -e "\n${GRN}$host${NC}"
        fi
        
        # Extract ports and services
        echo "$line" | grep -oP '\d+/open/[^/]+//[^/]+/[^/]*/' | while IFS= read -r port_info; do
            # Parse the grepable format: port/state/protocol//service/version/
            local port=$(echo "$port_info" | cut -d'/' -f1)
            local service=$(echo "$port_info" | cut -d'/' -f5)
            local version=$(echo "$port_info" | cut -d'/' -f6)
            
            # Color code based on common attack surface ports
            if [[ "$port" =~ ^(21|22|23|25|80|443|445|3306|3389|5432|8080|8443)$ ]]; then
                echo -e "  ${RED}â†’ $port${NC}/${YEL}$service${NC} ${DGRY}$version${NC}"
            else
                echo -e "  ${CYN}â†’ $port${NC}/${service} ${DGRY}$version${NC}"
            fi
        done
    done
    
    echo -e "\n${DGRY}$(printf '%.0sâ”€' {1..50})${NC}"
    
    # Save parsed results for later use
    grep "Ports:" "$gnmap_file" > "$SESSION_DIR/$RECON_DIR/parsed_ports.txt"
    echo -e "${GRN}[âœ“] Results saved to: $SESSION_DIR/$RECON_DIR/${NC}\n"
}

# ============================================
# SECTION 13: WEB SERVICE ENUMERATION
# ============================================
# Automatically detect and enumerate web services. This integration evolved
# from scan07's introduction of Gobuster to scan09's refined implementation.
# When you find web ports, you need to know what's running on them.
#
# Modify this section to: Use different wordlists for different scenarios
# (WordPress, Joomla, API endpoints), implement recursive scanning, add
# extension bruteforcing, or integrate additional web tools like nikto.

enumerate_web_services() {
    if [ "$ENABLE_WEB_ENUM" != true ]; then
        return
    fi
    
    local scan_results="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.nmap"
    
    if [ ! -f "$scan_results" ]; then
        echo -e "${YEL}[!] No scan results found, skipping web enumeration${NC}"
        return
    fi
    
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘     WEB SERVICE ENUMERATION       â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    # Check for common web ports
    local web_ports=$(grep -E "80/open|443/open|8080/open|8443/open|8000/open" "$scan_results")
    
    if [ -z "$web_ports" ]; then
        echo -e "${CYN}[*] No web services detected${NC}"
        return
    fi
    
    if ! command -v "$GOBUSTER_CMD" &> /dev/null; then
        echo -e "${YEL}[!] Gobuster not installed, skipping web enumeration${NC}"
        return
    fi
    
    echo -e "${GRN}[âœ“] Web services detected, launching directory enumeration${NC}\n"
    
    # Find best available wordlist
    local wordlist=""
    local wordlist_paths=(
        "/usr/share/wordlists/dirb/common.txt"
        "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt"
        "/usr/share/seclists/Discovery/Web-Content/common.txt"
        "/usr/share/wordlists/seclists/Discovery/Web-Content/common.txt"
    )
    
    for wl in "${wordlist_paths[@]}"; do
        if [ -f "$wl" ]; then
            wordlist="$wl"
            break
        fi
    done
    
    if [ -z "$wordlist" ]; then
        echo -e "${RED}[!] No wordlist found, cannot enumerate${NC}"
        return
    fi
    
    echo -e "${CYN}[*] Using wordlist: $wordlist${NC}\n"
    
    # Parse each web service and enumerate
    echo "$web_ports" | while IFS= read -r line; do
        local port=$(echo "$line" | awk '{print $1}' | cut -d'/' -f1)
        
        # Determine protocol
        local proto="http"
        if [[ "$port" == "443" ]] || [[ "$port" == "8443" ]]; then
            proto="https"
        fi
        
        # Build URL
        local url="${proto}://${TARGET}:${port}"
        
        echo -e "${CYN}[*] Enumerating: $url${NC}"
        
        local output_file="$SESSION_DIR/$WEB_DISCOVERY_DIR/gobuster_port_${port}.txt"
        
        # Construct gobuster command
        # dir: directory enumeration mode
        # -u: URL target
        # -w: wordlist
        # -t: threads (50 is aggressive but manageable)
        # -k: skip SSL certificate verification
        # -q: quiet mode (less output noise)
        # -o: output file
        local gobuster_cmd="$GOBUSTER_CMD dir -u \"$url\" -w \"$wordlist\" -t 50 -k -q -o \"$output_file\""
        
        # Add proxy if enabled
        if [ "$ENABLE_PROXY" = true ]; then
            gobuster_cmd="$PROXY_CMD $gobuster_cmd"
        fi
        
        # Execute in background to enumerate multiple ports simultaneously
        eval "$gobuster_cmd" 2>/dev/null &
        
        # Track the PID for cleanup if needed
        echo $! >> "$SESSION_DIR/$LOG_DIR/gobuster_pids.txt"
    done
    
    # Wait for all gobuster processes to complete
    echo -e "${YEL}[*] Waiting for enumeration to complete...${NC}"
    wait
    
    # Display findings
    echo -e "\n${GRN}[âœ“] Web enumeration complete${NC}"
    echo -e "${CYN}[*] Results saved to: $SESSION_DIR/$WEB_DISCOVERY_DIR/${NC}\n"
    
    # Quick summary of interesting findings
    if ls "$SESSION_DIR/$WEB_DISCOVERY_DIR"/*.txt &> /dev/null; then
        echo -e "${WHT}Interesting Directories Found:${NC}"
        for file in "$SESSION_DIR/$WEB_DISCOVERY_DIR"/*.txt; do
            if [ -s "$file" ]; then
                local port=$(basename "$file" | grep -oP '\d+')
                echo -e "${YEL}Port $port:${NC}"
                head -10 "$file" | sed 's/^/  /'
                local count=$(wc -l < "$file")
                if [ "$count" -gt 10 ]; then
                    echo -e "  ${DGRY}... and $(($count - 10)) more${NC}"
                fi
                echo ""
            fi
        done
    fi
}

# ============================================
# SECTION 14: EXPLOIT RESEARCH & MAPPING
# ============================================
# Automatically search for known exploits matching discovered services.
# This bridges reconnaissance and exploitation. Evolved from scan04's basic
# searchsploit integration to scan09's comprehensive exploit mapping.
#
# Modify this section to: Add CVE database lookups, CVSS scoring integration,
# automatic exploit download and preparation, or filtering by exploit type.

search_exploits() {
    if [ "$ENABLE_EXPLOIT_SEARCH" != true ]; then
        return
    fi
    
    local scan_xml="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.xml"
    
    if [ ! -f "$scan_xml" ]; then
        echo -e "${YEL}[!] No XML scan results found${NC}"
        return
    fi
    
    if ! command -v "$SEARCHSPLOIT_CMD" &> /dev/null; then
        echo -e "${YEL}[!] Searchsploit not available, skipping exploit search${NC}"
        return
    fi
    
    echo -e "\n${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${RED}â•‘     EXPLOIT RESEARCH              â•‘${NC}"
    echo -e "${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${YEL}[*] Searching exploit database...${NC}"
    
    local exploit_file="$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt"
    
    # Use searchsploit's nmap integration
    $SEARCHSPLOIT_CMD --nmap "$scan_xml" > "$exploit_file" 2>/dev/null
    
    if [ -s "$exploit_file" ]; then
        echo -e "${RED}[!] POTENTIAL EXPLOITS IDENTIFIED${NC}\n"
        
        # Display results with formatting
        cat "$exploit_file" | head -20
        
        local total_exploits=$(grep -c "Exploit Title" "$exploit_file" || echo "0")
        
        if [ "$total_exploits" -gt 20 ]; then
            echo -e "\n${DGRY}... and $(($total_exploits - 20)) more exploits${NC}"
        fi
        
        echo -e "\n${GRN}[âœ“] Full exploit list: $exploit_file${NC}"
        
        # Extract Metasploit modules specifically
        local msf_modules=$(grep -o "exploits/[^']*" "$exploit_file" | wc -l)
        if [ "$msf_modules" -gt 0 ]; then
            echo -e "${CYN}[*] Found $msf_modules Metasploit-compatible exploits${NC}"
        fi
    else
        echo -e "${CYN}[*] No public exploits found for detected versions${NC}"
        echo -e "${DGRY}[*] This doesn't mean targets are secure, just no public exploits${NC}"
    fi
}

# ============================================
# SECTION 15: METASPLOIT INTEGRATION
# ============================================
# Generate Metasploit resource files to automate framework setup. This saves
# hours of manual configuration. Evolved through scan05-scan09 as MSF
# integration became increasingly sophisticated.
#
# Modify this section to: Add automatic payload generation, listener setup,
# post-exploitation module chains, or workspace-specific configurations.

generate_msf_resource() {
    if [ "$ENABLE_MSF_INTEGRATION" != true ]; then
        return
    fi
    
    local scan_xml="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.xml"
    local rc_file="$SESSION_DIR/$MSF_RESOURCE_DIR/auto_setup.rc"
    
    if [ ! -f "$scan_xml" ]; then
        echo -e "${YEL}[!] No scan data to import into Metasploit${NC}"
        return
    fi
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘     METASPLOIT INTEGRATION        â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${CYN}[*] Generating Metasploit resource file...${NC}"
    
    # Create comprehensive resource file
    cat > "$rc_file" <<EOF
# ============================================
# Metasploit Resource File
# Auto-generated by s3rp Framework v${FRAMEWORK_VERSION}
# Session: $(basename "$SESSION_DIR")
# Generated: $(date '+%Y-%m-%d %H:%M:%S')
# ============================================

# Enable command logging
spool $SESSION_DIR/$LOG_DIR/msf_console.log

# Create and switch to dedicated workspace
workspace -a s3rp_$(basename "$SESSION_DIR")

# Import scan data
db_import $scan_xml

# Display imported information
echo
echo "========================================="
echo " Discovered Hosts"
echo "========================================="
hosts

echo
echo "========================================="
echo " Discovered Services"
echo "========================================="
services

echo
echo "========================================="
echo " Identified Vulnerabilities"
echo "========================================="
vulns

# ============================================
# SUGGESTED EXPLOIT MODULES
# ============================================
# The following modules were identified by searchsploit
# Uncomment and configure as needed:

EOF
    
    # Extract Metasploit modules from searchsploit results
    local exploit_file="$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt"
    if [ -f "$exploit_file" ]; then
        grep "exploits/remote/" "$exploit_file" | \
        awk '{print $NF}' | \
        sed 's/\.rb$//' | \
        sed 's|^|# use exploit|' | \
        sort -u >> "$rc_file"
    fi
    
    # Add handler configuration template
    cat >> "$rc_file" <<'EOF'

# ============================================
# REVERSE SHELL HANDLER TEMPLATE
# ============================================
# Configure based on your payload needs:

# For Windows Meterpreter:
# use exploit/multi/handler
# set PAYLOAD windows/x64/meterpreter/reverse_tcp
# set LHOST <YOUR_IP>
# set LPORT 4444
# set ExitOnSession false
# exploit -j -z

# For Linux Meterpreter:
# use exploit/multi/handler
# set PAYLOAD linux/x64/meterpreter/reverse_tcp
# set LHOST <YOUR_IP>
# set LPORT 4444
# set ExitOnSession false
# exploit -j -z

# For Generic Shell:
# use exploit/multi/handler
# set PAYLOAD generic/shell_reverse_tcp
# set LHOST <YOUR_IP>
# set LPORT 4444
# set ExitOnSession false
# exploit -j -z

# ============================================
# POST-EXPLOITATION AUTOMATION
# ============================================
# Uncomment to run post-exploitation modules automatically:

# use post/multi/recon/local_exploit_suggester
# use post/multi/gather/enum_network
# use post/multi/gather/enum_system

# ============================================
# END OF RESOURCE FILE
# ============================================
EOF
    
    echo -e "${GRN}[âœ“] Resource file generated: $rc_file${NC}"
    echo -e "${CYN}[*] Launch with: ${WHT}msfconsole -r $rc_file${NC}\n"
}

# ============================================
# SECTION 16: VULNERABILITY ASSESSMENT
# ============================================
# Quick assessment of common vulnerabilities and misconfigurations. This
# provides immediate actionable findings without deep manual analysis.
# Learned from scan04-scan09's NSE script usage patterns.
#
# Modify this section to: Add checks for specific CVEs, compliance
# violations (PCI-DSS, HIPAA), custom vulnerability signatures, or
# integration with commercial vulnerability scanners.

assess_vulnerabilities() {
    local scan_file="$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.nmap"
    
    if [ ! -f "$scan_file" ]; then
        return
    fi
    
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘     VULNERABILITY ASSESSMENT      â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${CYN}[*] Analyzing scan results for common vulnerabilities...${NC}\n"
    
    local findings=()
    local critical_findings=()
    
    # SMB Signing Check (learned from scan04's NSE usage)
    if grep -q "smb-security-mode" "$scan_file"; then
        if grep -A10 "smb-security-mode" "$scan_file" | grep -q "Message signing enabled but not required"; then
            critical_findings+=("SMB signing not enforced - NTLM relay attacks possible")
        fi
    fi
    
    # Anonymous FTP Access
    if grep -q "21/open" "$scan_file"; then
        if grep -q "Anonymous FTP login allowed" "$scan_file"; then
            findings+=("Anonymous FTP access enabled - data exposure risk")
        fi
    fi
    
    # Weak SSL/TLS Protocols
    if grep -q "ssl-cert\|ssl-enum-ciphers" "$scan_file"; then
        if grep -q "SSLv2\|SSLv3\|TLSv1\.0" "$scan_file"; then
            critical_findings+=("Weak SSL/TLS protocols detected - man-in-the-middle risk")
        fi
        if grep -q "VULNERABLE.*POODLE\|VULNERABLE.*BEAST\|VULNERABLE.*Heartbleed" "$scan_file"; then
            critical_findings+=("Known SSL/TLS vulnerabilities detected (Heartbleed/POODLE/BEAST)")
        fi
    fi
    
    # Default Credentials
    if grep -q "http-default-accounts\|default login" "$scan_file"; then
        critical_findings+=("Potential default credentials detected - authentication bypass risk")
    fi
    
    # Open Database Ports
    if grep -qE "3306/open|5432/open|1433/open|27017/open" "$scan_file"; then
        findings+=("Database ports exposed - should be firewalled from external access")
    fi
    
    # RDP Exposure
    if grep -q "3389/open" "$scan_file"; then
        findings+=("RDP exposed to network - brute-force and vulnerability risk")
    fi
    
    # Telnet (Unencrypted)
    if grep -q "23/open" "$scan_file"; then
        critical_findings+=("Telnet service detected - unencrypted remote access")
    fi
    
    # VNC Services
    if grep -qE "5900/open|5901/open" "$scan_file"; then
        findings+=("VNC service detected - check for authentication requirements")
    fi
    
    # Display critical findings first
    if [ ${#critical_findings[@]} -gt 0 ]; then
        echo -e "${RED}[!] CRITICAL SECURITY FINDINGS:${NC}"
        for finding in "${critical_findings[@]}"; do
            echo -e "  ${RED}ðŸ”´ $finding${NC}"
        done
        echo ""
    fi
    
    # Display regular findings
    if [ ${#findings[@]} -gt 0 ]; then
        echo -e "${YEL}[!] SECURITY FINDINGS:${NC}"
        for finding in "${findings[@]}"; do
            echo -e "  ${YEL}âš ï¸  $finding${NC}"
        done
        echo ""
    fi
    
    # If nothing found
    if [ ${#critical_findings[@]} -eq 0 ] && [ ${#findings[@]} -eq 0 ]; then
        echo -e "${GRN}[âœ“] No obvious vulnerabilities detected in automated assessment${NC}"
        echo -e "${CYN}[*] Manual review still recommended${NC}\n"
    fi
    
    # Save findings to file
    {
        echo "Vulnerability Assessment Report"
        echo "Generated: $(date)"
        echo "====================================="
        echo ""
        if [ ${#critical_findings[@]} -gt 0 ]; then
            echo "CRITICAL FINDINGS:"
            printf '%s\n' "${critical_findings[@]}"
            echo ""
        fi
        if [ ${#findings[@]} -gt 0 ]; then
            echo "FINDINGS:"
            printf '%s\n' "${findings[@]}"
        fi
    } > "$SESSION_DIR/$REPORT_DIR/vulnerability_assessment.txt"
}

# ============================================
# SECTION 17: COMPREHENSIVE REPORT GENERATION
# ============================================
# Compile all findings into a structured, professional report. Real
# engagements require documentation. This evolved from scan07's basic
# reporting to comprehensive, actionable deliverables.
#
# Modify this section to: Add executive summaries, risk scoring matrices,
# remediation recommendations, compliance mapping, or export to different
# formats (PDF, DOCX, JSON for SIEM integration).

generate_final_report() {
    local report_file="$SESSION_DIR/$REPORT_DIR/engagement_report.txt"
    
    echo -e "\n${WHT}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${WHT}â•‘     GENERATING FINAL REPORT       â•‘${NC}"
    echo -e "${WHT}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    
    echo -e "${CYN}[*] Compiling engagement data...${NC}"
    
    # Create comprehensive report
    cat > "$report_file" <<EOF
================================================================================
                    S3RP FRAMEWORK - ENGAGEMENT REPORT
================================================================================

SESSION INFORMATION
-------------------
Session ID:        $(basename "$SESSION_DIR")
Framework Version: $FRAMEWORK_VERSION
Target(s):         $TARGET
Scan Profile:      $PROFILE_NAME
Start Time:        $(grep "Start Time" "$SESSION_DIR/session_info.txt" | cut -d: -f2-)
End Time:          $(date '+%Y-%m-%d %H:%M:%S')
Operator:          $(whoami)
System:            $(grep "System" "$SESSION_DIR/session_info.txt" | cut -d: -f2-)

SCAN CONFIGURATION
------------------
Scan Flags:        $SCAN_FLAGS
Timing:            $TIMING
NSE Scripts:       $NSE_SCRIPTS
Proxy Layer:       $([ "$ENABLE_PROXY" = true ] && echo "Enabled" || echo "Disabled")
Min Packet Rate:   $DEFAULT_MIN_RATE packets/sec

DISCOVERY SUMMARY
-----------------
EOF
    
    # Add host count if available
    if [ -f "$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.gnmap" ]; then
        local hosts=$(grep -c "Status: Up" "$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.gnmap")
        echo "Live Hosts:        $hosts" >> "$report_file"
    fi
    
    # Add service count
    if [ -f "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" ]; then
        local services=$(grep -c "/" "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" 2>/dev/null || echo "0")
        echo "Open Services:     $services" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

DISCOVERED SERVICES
-------------------
EOF
    
    # Include parsed port information
    if [ -f "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" ]; then
        cat "$SESSION_DIR/$RECON_DIR/parsed_ports.txt" >> "$report_file"
    else
        echo "No services discovered" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

WEB DISCOVERY RESULTS
---------------------
EOF
    
    # Summarize web enumeration findings
    if ls "$SESSION_DIR/$WEB_DISCOVERY_DIR"/*.txt &> /dev/null 2>&1; then
        for file in "$SESSION_DIR/$WEB_DISCOVERY_DIR"/*.txt; do
            if [ -s "$file" ]; then
                local port=$(basename "$file" | grep -oP '\d+')
                local count=$(wc -l < "$file")
                echo "Port $port: $count directories/files found" >> "$report_file"
            fi
        done
    else
        echo "No web enumeration performed" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

EXPLOIT RESEARCH
----------------
EOF
    
    # Include exploit findings
    if [ -f "$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt" ]; then
        local exploit_count=$(grep -c "Exploit Title" "$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt" 2>/dev/null || echo "0")
        echo "Total Exploits Found: $exploit_count" >> "$report_file"
        echo "" >> "$report_file"
        grep "Exploit Title" "$SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt" | head -10 >> "$report_file" 2>/dev/null
        if [ "$exploit_count" -gt 10 ]; then
            echo "... and $(($exploit_count - 10)) more (see full report)" >> "$report_file"
        fi
    else
        echo "No exploit research performed" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

VULNERABILITY ASSESSMENT
------------------------
EOF
    
    # Include vulnerability assessment
    if [ -f "$SESSION_DIR/$REPORT_DIR/vulnerability_assessment.txt" ]; then
        tail -n +5 "$SESSION_DIR/$REPORT_DIR/vulnerability_assessment.txt" >> "$report_file"
    else
        echo "No vulnerability assessment performed" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

GENERATED ARTIFACTS
-------------------
Scan Results:      $SESSION_DIR/$RECON_DIR/
  - Nmap Output:   scan_${PROFILE_NAME}.nmap
  - XML Format:    scan_${PROFILE_NAME}.xml
  - Grepable:      scan_${PROFILE_NAME}.gnmap
EOF
    
    if [ -f "$SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.html" ]; then
        echo "  - HTML Report:   scan_${PROFILE_NAME}.html" >> "$report_file"
    fi
    
    cat >> "$report_file" <<EOF

Web Discovery:     $SESSION_DIR/$WEB_DISCOVERY_DIR/
Exploit Research:  $SESSION_DIR/$EXPLOIT_DIR/
MSF Resources:     $SESSION_DIR/$MSF_RESOURCE_DIR/
Logs:              $SESSION_DIR/$LOG_DIR/
Reports:           $SESSION_DIR/$REPORT_DIR/

NEXT STEPS & RECOMMENDATIONS
----------------------------
1. Review the HTML report for detailed service information:
   $SESSION_DIR/$RECON_DIR/scan_${PROFILE_NAME}.html

2. Investigate web directories found during enumeration:
   $SESSION_DIR/$WEB_DISCOVERY_DIR/

3. Launch Metasploit for exploitation (if MSF integration enabled):
   msfconsole -r $SESSION_DIR/$MSF_RESOURCE_DIR/auto_setup.rc

4. Validate identified exploits:
   Review $SESSION_DIR/$EXPLOIT_DIR/exploits_found.txt

5. Address identified vulnerabilities:
   See vulnerability assessment section above

6. Perform manual testing on interesting services

7. Document findings and prepare remediation recommendations

DISCLAIMER
----------
This report is generated automatically by the s3rp framework and should be
reviewed by a qualified security professional. Automated tools cannot detect
all vulnerabilities, and false positives may occur. Manual verification of
all findings is recommended.

================================================================================
Report generated by s3rp Framework v${FRAMEWORK_VERSION}
Developer: oxbv1 | 0xb0rn3 (AI-assisted with Google Gemini)
Generated: $(date '+%Y-%m-%d %H:%M:%S')
================================================================================
EOF
    
    echo -e "${GRN}[âœ“] Final report generated: $report_file${NC}\n"
    
    # Display summary to console
    echo -e "${WHT}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GRN}                  OPERATION COMPLETE${NC}"
    echo -e "${WHT}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${CYN}Session Directory:${NC} $SESSION_DIR"
    echo -e "${CYN}Final Report:${NC}      $report_file"
    echo ""
    echo -e "${YEL}Key Artifacts:${NC}"
    echo -e "  â€¢ Scan Results:   $SESSION_DIR/$RECON_DIR/"
    echo -e "  â€¢ Web Discovery:  $SESSION_DIR/$WEB_DISCOVERY_DIR/"
    echo -e "  â€¢ Exploits:       $SESSION_DIR/$EXPLOIT_DIR/"
    echo -e "  â€¢ MSF Setup:      $SESSION_DIR/$MSF_RESOURCE_DIR/"
    echo ""
    echo -e "${WHT}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

# ============================================
# SECTION 18: MAIN EXECUTION FLOW
# ============================================
# This is where we tie everything together. The main function orchestrates
# the entire engagement workflow. This structure makes it easy to customize
# the flow or add new modules.
#
# Modify this section to: Add pre-engagement steps (legal acknowledgment,
# scope verification), implement resume-from-checkpoint functionality,
# add post-engagement cleanup, or create custom workflow variations.

main() {
    # Display framework banner
    show_banner
    
    # Pre-flight checks
    echo -e "${CYN}[*] Running pre-flight checks...${NC}\n"
    check_privileges
    check_dependencies
    check_proxy_layer
    
    echo ""
    
    # Initialize operation session
    initialize_session
    
    # User configuration
    configure_target
    select_scan_profile
    
    # Confirm before starting
    echo -e "\n${YEL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${YEL}â•‘     OPERATION CONFIRMATION        â•‘${NC}"
    echo -e "${YEL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    echo -e "${WHT}Target:${NC}  $TARGET"
    echo -e "${WHT}Profile:${NC} $PROFILE_NAME"
    echo -e "${WHT}Proxy:${NC}   $([ "$ENABLE_PROXY" = true ] && echo "Enabled" || echo "Disabled")"
    echo ""
    read -p "Proceed with scan? (y/n): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${RED}[!] Operation cancelled by user${NC}"
        exit 0
    fi
    
    # Execute main workflow
    echo -e "\n${GRN}[âœ“] Starting operation workflow...${NC}\n"
    
    # Phase 1: Reconnaissance
    execute_scan
    
    # Phase 2: Web enumeration (if web services found)
    enumerate_web_services
    
    # Phase 3: Exploit research
    search_exploits
    
    # Phase 4: Metasploit integration
    generate_msf_resource
    
    # Phase 5: Vulnerability assessment
    assess_vulnerabilities
    
    # Phase 6: Final reporting
    generate_final_report
    
    # Success message
    echo -e "\n${GRN}[âœ“] All operations completed successfully${NC}"
    echo -e "${CYN}[*] Review the final report for detailed findings${NC}"
    echo -e "${CYN}[*] Happy hacking!${NC}\n"
}

# ============================================
# SCRIPT ENTRY POINT
# ============================================
# This is where execution begins. We call main() to start the framework.

main "$@"
